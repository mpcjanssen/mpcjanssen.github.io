<!DOCTYPE html>
<html lang="en">
  <head>
    <link href='//fonts.googleapis.com/css?family=Noticia+Text:400,700' rel='stylesheet' type='text/css' />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title> Building your own OS | The knights who say NIH! </title>

    <link rel="stylesheet" href="/theme/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/theme/css/font-awesome.css" type="text/css"/>
  </head>
  <body>
    <div class=container>

      <div class=navigation>
        <ul>
            <li><a href="/index.html">Blog</a> </li>
            <li><a href="/tags.html">Tags</a> </li>
            <li><a href="/pages/simpletask.html">Simpletask</a> </li>
            <li><a href="/redmine/">Tracker</a> </li>
            <li><a href="/pages/code.html">Code</a> </li>
        </ul>
      </div>
      <div class=separator></div>        
        <div class=body>
    <h1 class="title"> Building your own OS</h1>
    <p class=date> di 28 maart 2000 </p>
    <p>If you want to make your own OS and you like all clear cut code which compiles and does everything you would have ever wanted well then look further (go see Linux). But if you want to build your own OS including booting, switching to PM etcetera etcetera, then this is the place to be!</p>
<p>Recently I started my own attempt at writing an OS, well you can't exactly call it that right now, it only boots from
a floppy and switches to Protected Mode right now, but that was hard enough to figure out.</p>
<p>Although there is a lot of info on the net concerning PM, boot sectors, BIOS and all, I have yet to find a
place where all this stuff is treated step by step (and explained as well).</p>
<p>The following sections are an attempt to guide you through the pitfalls (especially switching to Protected Mode)
of booting from a floppy drive, switching to protected mode and loading a kernel (a very simple one).</p>
<p>As my own project will progress I will try to take you along with me. So the order in which subjects are treated is probably not the most logical or most educational but it happens to be the order in which I stumbled (or better fell and broke a leg :-)) across things.</p>
<p>I hope this will help you
in finding the right path (a well at least a path) through the slippery stuff called OS-programming
and that you will have fun doing it. If
you have any comments, suggestions or burning questions or if you want to point out some terrible
mistakes I made, please feel free to contact
me.</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#things-you-should-know-or-have-to-get-started" id="id1">Things you should know or have to get started</a></li>
<li><a class="reference internal" href="#booting-the-pc-and-the-boot-sector" id="id2">Booting the PC and the boot sector</a></li>
<li><a class="reference internal" href="#the-dos-boot-sector" id="id3">The DOS boot sector</a><ul>
<li><a class="reference internal" href="#dos-boot-sector-layout" id="id4">DOS boot sector layout</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protected-mode-what-is-it-all-about" id="id5">Protected Mode, what is it all about?</a></li>
<li><a class="reference internal" href="#how-the-pc-behaves-in-real-mode" id="id6">How the PC behaves in real mode</a></li>
<li><a class="reference internal" href="#how-the-pc-behaves-in-protected-mode" id="id7">How the PC behaves in Protected Mode</a><ul>
<li><a class="reference internal" href="#segmentation-in-protected-mode" id="id8">Segmentation in Protected Mode</a></li>
<li><a class="reference internal" href="#the-global-descriptor-table" id="id9">The Global Descriptor Table</a></li>
<li><a class="reference internal" href="#segment-selectors" id="id10">Segment Selectors</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="things-you-should-know-or-have-to-get-started">
<h2><a class="toc-backref" href="#id1">Things you should know or have to get started</a></h2>
<p>&gt;It is assumed you have a Pentium computer at your disposal (though a lot of stuff will work on a 386 as well).
Further I use The Netwide Assembler, <a class="reference external" href="http://www.nasm.us/">NASM</a> for short, because it's ease of use (much more logical than MASM or TASM in my humble opinion), because everybody else uses it and because it is FREE (well you're from Holland or you're not :-)). Last but not least you have to be a little insane ;-) (Thanx to Raphael Gray for pointing out this very important prerequisite)
Further more I assume you have the best debugger of all time, <cite>debug.exe</cite>
(included in windows and dos) &quot;installed&quot;
on your system. Well guess that's all so let's get dirty. And start with that magical process called booting.</p>
</div>
<div class="section" id="booting-the-pc-and-the-boot-sector">
<h2><a class="toc-backref" href="#id2">Booting the PC and the boot sector</a></h2>
<p>When you switch on your computer, program execution starts at memory location <cite>F000:FFF0</cite>. (this is a real mode address,
if you don't get that right now, don't worry I will get to that when I discuss Protected Mode, and it isn't that important
anyway.) This memory location is part of the ROM-BIOS (Basic Input/Output System) which is installed in all IBM compatibles. The computer
then starts executing a routine called the POST (Power On Self Test) which checks if a keyboard is plugged
in, if the CMOS OK and that kind of stuff. Not very interesting from an OS-programmer's point of view. But the
last action the POST takes is looking for a bootable disk. Hey this gets more interesting!</p>
<p>The BIOS checks your drives in the order which is defined in your BIOS-SETUP. (when we start testing
some boot disks we'll be booting from a floppy drive, so make sure your BIOS checks your flops first)
But how does it know that a disk is bootable? Simple a bootable disk has the signature <cite>0AA55h</cite> (h=hexadecimal) in the last
two bytes (that is <cite>55h</cite> in the second last and <cite>AAh</cite> in the last byte because of the Endian byte ordering in the
x86 family).
If this signature is found, sector 0 (the boot sector which is 200h=512 bytes big) is loaded in memory
at location <cite>0000:7C00h</cite> and control is transferred to this address.  Well that wasn't so hard, was it ?
So lets try to
write or own boot sector which only displays:</p>
<div class="highlight"><pre>NO BOOT DISK
</pre></div>
<p>and then totally freezes.  (to keep it simple) Here we go:</p>
<div class="highlight"><pre><span class="c1">;------------------------------------------------------------------------------------------</span>
<span class="c1">; dumbboot.asm</span>
<span class="c1">; demonstrates getting control after the compu has booted</span>
<span class="c1">; does nothing but display &quot;NO BOOT DISK&quot;  and freeze</span>
<span class="c1">;</span>
<span class="c1">; compile with NASM to binary file (nasm is assumed to be in your path)</span>
<span class="c1">;  nasm dumbboot.asm</span>
<span class="c1">;</span>
<span class="c1">; written by emJay (c) 1998 last updated 29-08-98</span>
<span class="c1">;</span>
<span class="c1">;------------------------------------------------------------------------------------------</span>

   <span class="k">org</span> <span class="mh">07C00h</span>                      <span class="c1">;this tells nasm that the first byte will be positioned</span>
                                   <span class="c1">;at address 0000:07C00h so that all the jumps will</span>
                                   <span class="c1">;be correct</span>

   <span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">begin_bootroutine</span>     <span class="c1">;jump to the start of our bootroutine skipping any data</span>

<span class="nl">BootMessage:</span> <span class="kd">db</span> <span class="s">&quot;NO BOOT DISK&quot;</span>     <span class="c1">;reserve space for the bootmessage and initialize it</span>
<span class="no">MessageLength</span><span class="kd"> equ</span> <span class="kc">$</span><span class="o">-</span><span class="nv">BootMessage</span>    <span class="c1">;calculate the length of the boot message at compile time</span>

<span class="nl">begin_bootroutine:</span>                 <span class="c1">;this is where the bootroutine starts</span>

   <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mi">0</span>
   <span class="nf">mov</span> <span class="nb">es</span><span class="p">,</span> <span class="nb">ax</span>                      <span class="c1">;point es to the segment of the boot message</span>
   <span class="nf">mov</span> <span class="nb">cx</span><span class="p">,</span> <span class="nv">MessageLength</span>

   <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span><span class="mh">01301h</span>                   <span class="c1">;Function 13h (ax=13h) Attribute in bl (al = 01h)</span>
   <span class="nf">mov</span> <span class="nb">bx</span><span class="p">,</span><span class="mh">0007h</span>                    <span class="c1">;screen page 0 (bh=0)  white on black (bl=07h)</span>
   <span class="nf">mov</span> <span class="nb">dx</span><span class="p">,</span><span class="mi">0</span>                        <span class="c1">;start in left corner</span>
   <span class="nf">mov</span> <span class="nb">bp</span><span class="p">,</span> <span class="nv">BootMessage</span>             <span class="c1">;takes offset of BootMessage (no offset keyword, GREAT!)</span>
   <span class="nf">int</span> <span class="mh">10h</span>                         <span class="c1">;display the string</span>

   <span class="nl">spin:</span> <span class="nf">jmp</span> <span class="nv">short</span>  <span class="nb">sp</span><span class="nv">in</span>           <span class="c1">;go into an infinite loop</span>

   <span class="kd">times</span> <span class="mi">510</span><span class="o">-</span><span class="p">(</span><span class="kc">$</span><span class="o">-</span><span class="kc">$$</span><span class="p">)</span> <span class="nv">db</span> <span class="mi">0</span>           <span class="c1">;fill with zeroes until byte 510 of the boot sector</span>
                                   <span class="c1">;See NASM doc for more info on $ and $$)</span>
   <span class="kd">dw</span> <span class="mh">0xAA55</span>                       <span class="c1">;write boot signature (actually goes in memory as 55h AAh)</span>
</pre></div>
<p>Got that? Well lets compile it using <a class="reference external" href="http://www.nasm.us/">NASM</a></p>
<blockquote>
nasm dumbboot.asm</blockquote>
<p>This gives a file called &quot;dumbboot&quot; which an exact binary picture so no headers. Now type (assuming you use A:)</p>
<blockquote>
debug dumbboot
- w 100 0 0 1
- q</blockquote>
<p>This writes your homemade bootsector to A:. (to use B: type <cite>w 100 1 0 1</cite>)
Now reboot your PC and TADA we've grabbed control, isn't that great?</p>
</div>
<div class="section" id="the-dos-boot-sector">
<h2><a class="toc-backref" href="#id3">The DOS boot sector</a></h2>
<p>The previous boot sector has one big problem. DOS won't recognize the disk
anymore. So
if we would want to put a new bootsector at the disk, debug gives a write
error, because it
hasn't got a clue wat type of disk it is.</p>
<p>Well, how does DOS know what kind of disk is inserted? Very simple, on the
bootsector there
are some reserved fields which tell DOS what kind of disk it is. And
because our previous
bootsector uses those fields to store code, DOS can't handle the disk
anymore. So let's
fix that! The fields in the bootsector are defined as follows:</p>
<div class="section" id="dos-boot-sector-layout">
<h3><a class="toc-backref" href="#id4">DOS boot sector layout</a></h3>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="74%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Offset</th>
<th class="head">Field description</th>
<th class="head">Length of field</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>00h</td>
<td>Short (JMP xx , NOP) or long (JMP xxx)  jump to begin of boot routine</td>
<td>3 bytes</td>
</tr>
<tr><td>03h</td>
<td>OEM identification</td>
<td>8 bytes</td>
</tr>
<tr><td>0Bh</td>
<td>Bytes per sector</td>
<td>1 word</td>
</tr>
<tr><td>0Dh</td>
<td>Sectors per cluster</td>
<td>1 byte</td>
</tr>
<tr><td>0Eh</td>
<td>Number of reserved sectors</td>
<td>1 word</td>
</tr>
<tr><td>10h</td>
<td>Number of FATs</td>
<td>1 byte</td>
</tr>
<tr><td>11h</td>
<td>Number of entries in root directory</td>
<td>1 word</td>
</tr>
<tr><td>13h</td>
<td>Number of sectors in volume</td>
<td>1 word</td>
</tr>
<tr><td>15h</td>
<td>Media descriptor</td>
<td>1 byte</td>
</tr>
<tr><td>16h</td>
<td>Number of sectors per FAT</td>
<td>1 word</td>
</tr>
<tr><td>18h</td>
<td>Sectors per track</td>
<td>1 word</td>
</tr>
<tr><td>1Ah</td>
<td>Number of read/write heads</td>
<td>1 word</td>
</tr>
<tr><td>1Ch</td>
<td>Number of hidden sectors</td>
<td>1 word</td>
</tr>
<tr><td>1Eh-1FDh</td>
<td>Boot routine</td>
<td>480 bytes</td>
</tr>
<tr><td>1FEh</td>
<td>55h</td>
<td>1 byte</td>
</tr>
<tr><td>1FFh</td>
<td>AAh</td>
<td>1 byte</td>
</tr>
</tbody>
</table>
</blockquote>
<p>OK that seems pretty straightforward, so let's try to put it to practice.
In the following piece of
code I am assuming you use a 3,5&quot; HD disk.</p>
<div class="highlight"><pre><span class="c1">;------------------------------------------------------------------------------------------</span>
<span class="c1">; dosboot.asm</span>
<span class="c1">; demonstrates getting control after the compu has booted</span>
<span class="c1">; does nothing but display &quot;NO BOOT DISK&quot;  and freeze</span>
<span class="c1">; while DOS is still able to read/write the disk</span>
<span class="c1">;</span>
<span class="c1">; compile with NASM to binary file (nasm is assumed to be in your path)</span>
<span class="c1">;  nasm dosboot.asm</span>
<span class="c1">;</span>
<span class="c1">; written by emJay (c) 1998 last updated 31-08-98</span>
<span class="c1">;</span>
<span class="c1">;------------------------------------------------------------------------------------------</span>
   <span class="k">org</span> <span class="mh">07C00h</span>                      <span class="c1">;this tells nasm that the first byte will be positioned</span>
                                   <span class="c1">;at address 0000:07C00h so that all the jumps will</span>
                                   <span class="c1">;be correct</span>

   <span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">begin_bootroutine</span>     <span class="c1">;jump to the start of our bootroutine skipping any data</span>
   <span class="nf">nop</span>                             <span class="c1">;first field must be 3 bytes long jmp short is 2 bytes</span>
   <span class="kd">db</span> <span class="s">&#39;MajOS1.0&#39;</span>                   <span class="c1">;OEM identification</span>
   <span class="kd">dw</span> <span class="mi">512</span>                          <span class="c1">;Bytes per sector</span>
   <span class="kd">db</span> <span class="mi">1</span>                            <span class="c1">;Sectors per cluster</span>
   <span class="kd">dw</span> <span class="mi">1</span>                            <span class="c1">;Number of reserved sectors</span>
   <span class="kd">db</span> <span class="mi">2</span>                            <span class="c1">;Number of FATs</span>
   <span class="kd">dw</span> <span class="mh">0E0h</span>                         <span class="c1">;Number of dirs in root</span>
   <span class="kd">dw</span> <span class="mh">0B40h</span>                        <span class="c1">;Number of sectors in volume</span>
   <span class="kd">db</span> <span class="mh">0F0h</span>                         <span class="c1">;Media descriptor</span>
   <span class="kd">dw</span> <span class="mi">9</span>                            <span class="c1">;Number of sectors per FAT</span>
   <span class="kd">dw</span> <span class="mi">18</span>                           <span class="c1">;Number of sectors per track</span>
   <span class="kd">dw</span> <span class="mi">2</span>                            <span class="c1">;Number of read/write heads</span>
   <span class="kd">dw</span> <span class="mi">0</span>                            <span class="c1">;Number of hidden sectors</span>

<span class="nl">begin_bootroutine:</span>                 <span class="c1">;this is where the bootroutine starts</span>

   <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mi">0</span>
   <span class="nf">mov</span> <span class="nb">es</span><span class="p">,</span> <span class="nb">ax</span>                      <span class="c1">;point es to the segment of the boot message</span>
   <span class="nf">mov</span> <span class="nb">cx</span><span class="p">,</span> <span class="nv">MessageLength</span>

   <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span><span class="mh">01301h</span>                   <span class="c1">;Function 13h (ax=13h) Attribute in bl (al = 01h)</span>
   <span class="nf">mov</span> <span class="nb">bx</span><span class="p">,</span><span class="mh">0007h</span>                    <span class="c1">;screen page 0 (bh=0)  white on black (bl=07h)</span>
   <span class="nf">mov</span> <span class="nb">dx</span><span class="p">,</span><span class="mi">0</span>                        <span class="c1">;start in left corner</span>
   <span class="nf">mov</span> <span class="nb">bp</span><span class="p">,</span> <span class="nv">BootMessage</span>             <span class="c1">;takes offset of BootMessage (no offset keyword, GREAT!)</span>
   <span class="nf">int</span> <span class="mh">10h</span>                         <span class="c1">;display the string</span>

   <span class="nl">spin:</span> <span class="nf">jmp</span> <span class="nv">short</span>  <span class="nb">sp</span><span class="nv">in</span>           <span class="c1">;go into an infinite loop</span>

   <span class="kd">times</span> <span class="mi">510</span><span class="o">-</span><span class="p">(</span><span class="kc">$</span><span class="o">-</span><span class="kc">$$</span><span class="p">)</span> <span class="nv">db</span> <span class="mi">0</span>           <span class="c1">;fill with zeroes until byte 510 of the boot sector</span>
                                   <span class="c1">;See NASM doc for more info on $ and $$)</span>
   <span class="kd">dw</span> <span class="mh">0xAA55</span>                       <span class="c1">;write boot signature (actually goes in memory as 55h AAh)</span>
</pre></div>
<p>OK now reformat your boot disk (format a: /u) compile dosboot.asm and
write it to the bootsector
of your bootdisk, just as you did before.</p>
<p>This disk can now again be used as a normal DOS disk, you can view it and
put files on it, but when
you boot from it, it still displays NO BOOT DISK, try it!</p>
<p>I hope these two sections gave you some feel of the boot process and the
boot sector. If you want more information
check out Michael Tischer's book. OK please go to the toilet, take a
snack, drink some coffee and then read on because we're going to look at
Protected Mode!</p>
</div>
</div>
<div class="section" id="protected-mode-what-is-it-all-about">
<h2><a class="toc-backref" href="#id5">Protected Mode, what is it all about?</a></h2>
<p>Although through the years most PC's have been equiped with more and more
memory, all DOS programs still
had to deal with the infamous 640 KB limit. Why wasn't it possible to
access all those MB's you had installed
on your system? Because even the newest processor had to be able to
execute the 8086's code it
had to operate in the same way. This means you only had 20-bit addresses
giving a total accessible
memory of <span class="formula">2<sup>20</sup> = 1<i>MB</i></span>
, even if you had 40 MB plugged in your
system. On a pentium however we have a 32-bits wide
address bus which gives a theoretical address space of <span class="formula">2<sup>32</sup> = 4<i>GB</i></span>
!</p>
<p>How can we access al this additional memory. Well we have to leave the
8086's  real mode and switch
to the incredible Protected Mode.
Do you want a codesegment of 4 GB? Do you want to put the entire
Encyclopedia Brittanica in your datasegment?
Well just do it, switch to Protected Mode (PM) and you've got access to
all the memory you would ever want.</p>
</div>
<div class="section" id="how-the-pc-behaves-in-real-mode">
<h2><a class="toc-backref" href="#id6">How the PC behaves in real mode</a></h2>
<p>When you reboot the PC it enters a mode known as real mode. This mode
gives maximum
compatibility with the 8086 and some extra features (such as extended
registers, faster instructions  ,additional instructions etc. etc.).</p>
<p>In this mode memory is divided in segments of 64 KB (16 bits) with a total
addressable space
of <span class="formula">2<sup>20</sup> = 1024<i>KB</i></span>
. Memory locations are accessed through a
segment:offset
address (the so called <em>logical address</em>). Calculation of the
<em>physical address</em> (the actual byte number in memory) is performed in
the
following way:</p>
<div class="formula">
<i>physical</i><i>address</i> = 10<i>h</i>*<i>segment</i> + <i>offset</i>
</div>
<p>For example if we take segment 9000h and offset 8000h (logical address
9000:8000h) we get physical
address <span class="formula">9000<i>h</i>*10<i>h</i> + 8000<i>h</i> = 90000<i>h</i> + 8000<i>h</i> = 98000<i>h</i></span>
. (Note that this address
refers to
the same physical memory location as for instance 9300:5000h so segments
overlap in real mode)
To access different segments, 16-bit segment registers (such as cs, ds and
es) are used so that
the maximum address is <span class="formula"><i>FFFF</i>:000<i>Fh</i> = <i>FFFFFh</i><i>physical</i> = 2<sup>20</sup></span>
.</p>
<p>The
maximal address accessable address would be  FFFF:FFFFh = 10FFEFh
physical, but this can't be expressed in 20 bits. However if we find a way
to access an additional address line (the most
famous A20 line) we can even use this additional
FFFF:FFFFh-FFFF:000Fh=FFF0h=65520 bytes.
(the so called  High Memory Area (HMA)) But why do we have to
enable this A20 line? Why isn't it enabled at boot up?</p>
<p>If the A20 line would be enabled then if we got the highest 20 bit
address
FFFF:000Fh = FFFFFh and we would  go one byte further (FFFF:0010h)  we
would access the physical address
100000h (1 0000 0000 0000 0000 0000b), however at the 8086 there is no A20
(this is the 21st addressline because we start at A0) so that
FFFF:000Fh+1=
0000:0000h  dropping the carry.  Because some programs use this memory
wrap
feature on the 8086, the A20 has to be disabled for complete backward
compatibility.</p>
<p>There is however a way to enable this A20 address line (this is what
himem.sys does on MS-DOS
computers giving an additional memoryblock of almost 64K for device
drivers and so on).
We can use the keyboard controller to enable this A20 line, because the
A20 line is logical ANDed with a keyboard controller output, which is
disabled at boot up. This means that the 21st bit of an address is always:
0 AND x = 0. So all we have to do is
enable this keyboard controller output  to get: 1 AND x = x. (code to do
this will be presented in
a later chapter)  &lt;/p&gt;</p>
<p>Now how can we access A31-A22 to get the 4 GB addressable memory space?
You guessed it, by
switching to protected mode. However in PM, memory management is quite a
different ballplay so
let's check it out.</p>
</div>
<div class="section" id="how-the-pc-behaves-in-protected-mode">
<h2><a class="toc-backref" href="#id7">How the PC behaves in Protected Mode</a></h2>
<div class="section" id="segmentation-in-protected-mode">
<h3><a class="toc-backref" href="#id8">Segmentation in Protected Mode</a></h3>
<p>In PM segmentation is performed in quite a different manner. Here a
segmentregister (CS, DS, ES
FS, GS or SS) contains a <em>segment selector</em> which is a pointer to a
<em>segment descriptor</em> in the <em>Global or Local  Descriptor Table (GDT
or LDT)</em></p>
<p>The segment descriptor (64 bits)  contains information about the segment,
like access rights, size, and base address.
Let's take a look at a segment descriptors fields</p>
<div class="figure">
<img alt="Segment Descriptor" src="/images/SegmentDescriptor.png" style="width: 100%;" />
<p class="caption">Segment Descriptor</p>
<div class="legend">
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td>A</td>
<td>Available for use by programmer</td>
</tr>
<tr><td>Base</td>
<td>Segment Base Address</td>
</tr>
<tr><td>DB</td>
<td>Default operation size (0 = 16-bit segment; 1 = 32-bit segment)</td>
</tr>
<tr><td>DPL</td>
<td>Descriptor privilege level</td>
</tr>
<tr><td>G</td>
<td>Granularity</td>
</tr>
<tr><td>Limit</td>
<td>Segment limit</td>
</tr>
<tr><td>P</td>
<td>Segment present</td>
</tr>
<tr><td>S</td>
<td>Descriptor type (0 = system; 1 = code or data)</td>
</tr>
<tr><td>Type</td>
<td>Segment type</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Let's take a look at all those fields in a bit more detail.&lt;/p&gt;</p>
<ul>
<li><p class="first">A: this bit is available for your own use, for instance to create
your own virtual memory manager.</p>
</li>
<li><p class="first">Base: this is the base address of the segment.
Because it's 32 bits long, a segment can start on any physical memory place
(not just at 64K borders as in real mode) if this field contains for
instance 5555:0000h, then this segment will start at physical  address
55550000h. (so no multiplication with 10h as in real mode) However with
speed in mind it is wise to let a segment
start on a 16-byte boundary.</p>
</li>
<li><p class="first">DB: This field performs different functions depending on the segment Type. This flag is always
1 for 32-bit code and data segments and 0 for 16-bit code and data segments.</p>
</li>
<li><p class="first">DPL:  These two bits give the privilege level of the segment ranging
from 0 (highest privilege) to 3
(lowest privilege). This flag is used to control access to a segment.</p>
</li>
<li><p class="first">Limit: Gives the size of the segment. Although it's only 20 bits long,
a segment can be 4 GB long this is
achieved by setting the G bit.</p>
</li>
<li><p class="first">G: If this bit is set the actual segment size is the limit times 4 KB
(<span class="formula">1<i>MB</i>*4<i>K</i> = 4<i>GB</i></span>
), if this flag
is clear the size of the segment is the limit in bytes. So for segments
bigger than 1 MB the size
must be a mutiple of 4 KB, but this is no real restriction.</p>
</li>
<li><p class="first">P: This flag indicates whether the segment is present in memory (set)
or not present (clear).
If this flag is clear the processor generates an segment not present
exception (#NP) when a segment
selector that points to the segment descriptor is loaded in a segment
register. When we are not
using virtual memory or paging this flag is usually set.</p>
</li>
<li><p class="first">S: Specifies a system segment (clear) or a code or data segment (set).</p>
</li>
<li><p class="first">Type: Indicates the segment type (note that bits 10-8 have different
names depending on bit 11 (code or data)) :</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="4%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="19%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Hexadecimal</th>
<th class="head">11</th>
<th class="head">10</th>
<th class="head">9</th>
<th class="head">8</th>
<th class="head">Descriptor Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>E</em></td>
<td><em>W</em></td>
<td><em>A</em></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Data</td>
<td>Read-Only</td>
</tr>
<tr><td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>Data</td>
<td>Read-Only Accessed</td>
</tr>
<tr><td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Data</td>
<td>Read-Write</td>
</tr>
<tr><td>3</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>Data</td>
<td>Read-Write Accessed</td>
</tr>
<tr><td>4</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Data</td>
<td>Read-Only, Expand down</td>
</tr>
<tr><td>5</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>Data</td>
<td>Read-Only, Expand down,  Accessed</td>
</tr>
<tr><td>6</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Data</td>
<td>Read-Write, Expand down</td>
</tr>
<tr><td>7</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Data</td>
<td>Read-Write, Expand down, Accessed</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td><em>C</em></td>
<td><em>R</em></td>
<td><em>A</em></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>8</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Code</td>
<td>Execute-Only</td>
</tr>
<tr><td>9</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>Code</td>
<td>Execute-Only, accessed</td>
</tr>
<tr><td>A</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Code</td>
<td>Execute/Read</td>
</tr>
<tr><td>B</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>Code</td>
<td>Execute/Read,accessed</td>
</tr>
<tr><td>C</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Code</td>
<td>Execute-Only, conforming</td>
</tr>
<tr><td>D</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>Code</td>
<td>Execute-Only, conforming, accessed</td>
</tr>
<tr><td>E</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>Code</td>
<td>Execute/Read-Only, conforming</td>
</tr>
<tr><td>F</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Code</td>
<td>Execute/Read-Only, conforming, accessed</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>Because we would like to access a number of segments, we will need a lot
of segment descriptors (especially in a multi-tasking Operating System).
Therefore we make a table
of segment descriptors know as the Global Discriptor Table.</p>
</div>
<div class="section" id="the-global-descriptor-table">
<h3><a class="toc-backref" href="#id9">The Global Descriptor Table</a></h3>
<p>The global descriptor table (GDT) is a part of the memory where segment
descriptors are
defined. The first descriptor is located at the memory location which is
loaded in the
&lt;b&gt;Global Descriptor Table Register (GDTR)&lt;/b&gt;, this is a 48-bit register
containing the address of the
GDT (32 bits) and the length of the GDT in bytes  (16 bits) so there can
be 2&lt;sup&gt;16&lt;/sup&gt; / 8 = 8192 descriptors
in the GDT. The first descriptor in the GDT must be the so called &lt;b&gt;null
descriptor&lt;/b&gt;. This descriptor consists only of zeroes. And although this
isn't used by the system, it can be loaded to any data-segment register
(DS, ES, FS and GS) without generating an exception. Let's look at an
example of a GDT:</p>
<p>Let's look at the <em>Basic Flat Model</em>. This means that we have two
segments of 4 GB, a code and a data segment, which completely overlap in
memory. (So it is still possible, though not advisable, to write self
modifying
code):</p>
<div class="highlight"><pre><span class="nf">gdtr</span>                               <span class="c1">;this will be loaded in the GDTR</span>
   <span class="kd">dw</span> <span class="nv">gdt_end</span><span class="o">-</span><span class="nv">gdt</span><span class="o">-</span><span class="mi">1</span>                <span class="c1">;length of gdt</span>
   <span class="kd">dd</span> <span class="nv">gdt</span>                          <span class="c1">;linear, physical address of gdt</span>

<span class="nf">gdt</span>
<span class="nf">gdt0</span>                               <span class="c1">;null descriptor 64 bits is 2</span>
<span class="nf">doublewords</span>
   <span class="kd">dd</span> <span class="mi">0</span>
   <span class="kd">dd</span> <span class="mi">0</span>
<span class="nf">code_gdt</span>                           <span class="c1">;code descriptor 4 GB flat segment</span>
<span class="nf">starting</span> <span class="mi">0000</span><span class="p">:</span><span class="mh">0000h</span>
   <span class="kd">dw</span> <span class="mh">0ffffh</span>                       <span class="c1">;Limit bits 15:00</span>
   <span class="kd">dw</span> <span class="mh">0h</span>                           <span class="c1">;Base bits 15:00</span>
   <span class="kd">db</span> <span class="mh">0h</span>                           <span class="c1">;Base bits 23:16</span>
   <span class="kd">db</span> <span class="mh">09ah</span>                         <span class="c1">;Code execute read (0Ah)</span>
                                   <span class="c1">;Present, DPL 0 , non system segment (09h)</span>
   <span class="kd">db</span> <span class="mh">0cfh</span>                         <span class="c1">;Segment limit 19:16 (0Fh)</span>
                                   <span class="c1">;4 KB granularity, 32-bit , avl = 0 (0Ch)</span>
   <span class="kd">db</span> <span class="mh">0h</span>                           <span class="c1">;Segment Base 31:24</span>

<span class="nf">data_gdt</span>                           <span class="c1">;data descriptor 4 GB flat segment</span>
<span class="nf">starting</span> <span class="mi">0000</span><span class="p">:</span><span class="mh">0000h</span>
   <span class="kd">dw</span> <span class="mh">0ffffh</span>                       <span class="c1">;Limit bits 15:00</span>
   <span class="kd">dw</span> <span class="mh">0h</span>                           <span class="c1">;Base bits 15:00</span>
   <span class="kd">db</span> <span class="mh">0h</span>                           <span class="c1">;Base bits 23:16</span>
   <span class="kd">db</span> <span class="mh">092h</span>                         <span class="c1">;Data read/write (02h)</span>
                                   <span class="c1">;Present, DPL 0, non system segment (09h)</span>
   <span class="kd">db</span> <span class="mh">0cfh</span>                         <span class="c1">;Segment limit 19:16 (0Fh)</span>
                                   <span class="c1">;4 KB granularity, 32 bit ,avl = 0 (0Ch)</span>
   <span class="kd">db</span> <span class="mh">0h</span>                           <span class="c1">;Segment Base 31:24</span>

<span class="nf">videosel</span>                           <span class="c1">;simple way to write to video memory</span>
   <span class="kd">dw</span> <span class="mi">3999</span>                         <span class="c1">;Limit 80*25*2-1 (80*25 chars + attributes)</span>
   <span class="kd">dw</span> <span class="mh">0x8000</span>
   <span class="kd">db</span> <span class="mh">0x0B</span>                         <span class="c1">;Base 0xB8000</span>
                                   <span class="c1">;(in real mode segment 0B800h = 10h*0B800h = 0B8000h)</span>
   <span class="kd">db</span> <span class="mh">0x92</span>                         <span class="c1">;Data read/write (02h)</span>
                                   <span class="c1">;Present, DPL 0, non system segment (09h)</span>
   <span class="kd">db</span> <span class="mi">0</span>                            <span class="c1">;Segment limit 19:16 (0h)</span>
                                   <span class="c1">;byte-granular, 16-bit</span>
   <span class="kd">db</span> <span class="mi">0</span>                            <span class="c1">;Segment Base 31:24</span>
<span class="nf">gdt_end</span>
</pre></div>
<p>Now we have seen how to set up code and data segments it would be nice to
see how we can access these segments, this is done by loading segment
selectors in segment register.
&lt;a name=&quot;select&quot;&gt;</p>
</div>
<div class="section" id="segment-selectors">
<h3><a class="toc-backref" href="#id10">Segment Selectors</a></h3>
<p>A segment selector is a 16-bit value used to select a segment in the GDT.
First let's take a look at the
segment selector's format:</p>
<p>&lt;/p&gt;&lt;center&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;CENTER&quot; colspan=&quot;2&quot;&gt;
&lt;b&gt;Segment selector overview&lt;/b&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;CENTER&quot; colspan=&quot;2&quot;&gt;
&lt;pre&gt;
16                         3  2  1   0
----------------------------------------
|          Index             | T | RPL |
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Index: this is the index of the segment to be used in the GDT or LDT.
In our previous example of a GDT, the null selector would have an index of
0h, the code segment selector
an index of 1h and so on. I guess this is the actual reason why there can
only be 8192
selectora. (the index field is 13 bits wide and 2&lt;sup&gt;13&lt;/sup&gt; = 8192 =
2000h)
&lt;/li&gt;&lt;li&gt;TI: this tells the processor whether the descriptor should be taken
out of de GDT or the
LDT (Local Descriptor Table, this table can be defined for every seperate
process in
a multitasking environment). In our case TI = 0 so that we'll use the GDT.
&lt;/li&gt;&lt;li&gt;RPL: The requested privilege level must be smaller or equal to the
descriptor privilege level (so higher or same priority)   to be able to
access the segment. If this is not the case a general
protection exception will be generated (#GP). In our case we'll use  RPL =
0.
&lt;/li&gt;&lt;/ul&gt;</p>
<p>Assume we would want to access the datasegment from the GDT, with RPL = 0.
We would then have to load for example DS with 10h (0000 0000 0000 1000b).
If we now want to place a white on black 'a' (character code 041h color
attribute 07h) in the first place of the video memory we could say:&lt;/p&gt;</p>
<p>mov word [0xB8000],0x0741&lt;/p&gt;</p>
<p>We could also load for instance gs with 18h (selecting the videosegment)
and say:&lt;/p&gt;</p>
<p>mov word [gs:0],0x741 ;remember segment-base = 0xB8000 so offset = 0h&lt;/p&gt;</p>
<p>Now the only thing left mentioning is how to set up the GDTR. Well luckely
there is
a special instruction which does this for us: &lt;b&gt;lgdt (Load Global
descriptor table)&lt;/b&gt;.
The limit loaded in the GDTR is an offset to the last valid byte, so a
limit of 0 results in
exactly one valid byte. So if we would want to load the GDTR in our case
the limit
would be gdt_end-gdt-1, because the label gdt_end is one byte after the
last byte of the GDT,
which is exactly what I've put at label gdtr. The base address of our GDT
will be
0000:16-bit offset of gdt, or simpler just gdt. Again I have put that
there. So all we have
to do is load the GDTR with the value specified at gdt:&lt;/p&gt;</p>
<blockquote>
o32 lgdt [gdtr]&lt;/p&gt;</blockquote>
<p>o32 is a NASM keyword which tells the assembler that our operator size
prefix is 32-bit, I don't
know whether this is absolutely necessary. (any suggestions?) &lt;/p&gt;</p>
<p>This is all we need to know about memory access in PM for the moment. Now
the time
has come to do the actual switch.</p>
<p>&lt;/p&gt;&lt;center&gt;&lt;h2&gt;8. Switching from real to Protected Mode&lt;/h2&gt;&lt;/center&gt;&lt;b&gt;The operation mode of the processor is controlled by the least
significant bit of the 32-bit
control register 0 (CR0), also called the protection enable (PE) bit.&lt;/b&gt;
Because it's paramount to leave the other bits unchanged this is done in
the following way:</p>
<p>&lt;/p&gt;&lt;pre&gt;mov eax,cr0            ;load eax with the contents of cr0
or eax,1               ;set the least significant bit leave the other bits
unchanged
mov cr0,eax            ;switch to PM
&lt;/pre&gt;</p>
<p>Before switching to PM, there are a few things you need to do:
&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;cli: Disable interrupts, because the installed interrupts are all
written for real
mode and if an interrupt would occur after the mode switch, your system
would probably reboot.
&lt;/li&gt;&lt;li&gt;Load the GDTR using lgdt, to set up the GDT.
&lt;/li&gt;&lt;li&gt;Execute a mov CR0 instruction to set the PE bit of control register 0.
&lt;/li&gt;&lt;li&gt;Immediately after the mov,cr0 instruction perform a far jump to clear
the instruction prefetch
queue, because it's still filled with real mode instructions and
addresses.
&lt;/li&gt;&lt;li&gt;Reload all the segment registers except CS. (which is reloaded by the
far jump)
&lt;/li&gt;&lt;li&gt; Load the Interrupt descriptor tables to make interrupts possible
&lt;/li&gt;&lt;li&gt;sti:  Re-enable interrupts.
&lt;/li&gt;&lt;li&gt;Enable the A20 line to prevent memorywrap.
&lt;/li&gt;&lt;/ol&gt;</p>
<p>In the following source, I am only going to load the GDT and switch to PM.
So I will not
set up a stack or an IDT, which is fine as long as you don't POP or PUSH
and leave
interrupts disabled. When you boot this example the following actions will
be taken:&lt;/p&gt;</p>
<p>&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;The screen will be erased.
&lt;/li&gt;&lt;li&gt;A brown 'a' will be printed in the left corner of the screen.
&lt;/li&gt;&lt;li&gt;The system will wait for a keypress.
&lt;/li&gt;&lt;li&gt;The switch to PM will be made.
&lt;/li&gt;&lt;li&gt;A white 'a' will be printed in the left corner of the screen.
&lt;/li&gt;&lt;li&gt;The system will go into an infinite loop (note that CTRL+ALT+DEL will
no longer function,
because interrupts are still disabled).
&lt;/li&gt;&lt;/ol&gt;</p>
<p>&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/pmboot.asm">http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/pmboot.asm</a>&quot;&gt;Download pmboot.asm&lt;/a&gt;&lt;/p&gt;</p>
<p>&lt;/p&gt;&lt;center&gt;&lt;h2&gt;9. Enable the A20 address line&lt;/h2&gt;&lt;/center&gt;In order to use the full amount of RAM plugged in your computer you have
to enable the a20 addressline. As mentioned earlier this can be done by
enabling a line of the floppy controller. The state of this line can be
changed by setting the appropriate bit. This bit is the second bit of the
AT keyboard controller output port. (port 064h) So in theory we can enable
the a20 address line by simply setting this second bit.</p>
<p>There are however some things to be taken into account. The keyboard
buffer (that is the buffer on the keyboard, not the BIOS-buffer) can still
contain some bytes which have to be handled first.
&lt;/p&gt;</p>
<p>If we have completly cleared the keyboard buffer we try to set the a20
line. This should then enable us to use the additional 64K HMA. So we can
test whether the a20 gate is enabled by writing a byte to FFFF:000Fh+1 and
check whether this byte is different from the one at 0000:0001h. Because
if a20 is enabled FFFF:000Fh+1=100000h physical and if a20 is not enabled
a wrap will occur thus writing a byte to 000000h physical. &lt;/p&gt;</p>
<p>To be able to see if the byte positioned at the physical address 00000h
has really changed we try to write the bit inverted (by using NOT) byte of
the original value of 00000h. In that manner it's always possible to see
if 00000h has changed (which would imply that a20 is not enabled). &lt;/p&gt;</p>
<p>The code I have used below is not written by me. (although I have added
some comments) I think Tran originally wrote this code for use in his
PMode protected mode wrapper. The piece of code conains a function
EnableA20 which should do exactly that. So here we go:
&lt;/p&gt;</p>
<div class="highlight"><pre> <span class="nl">enablea20kbwait:</span>                      <span class="c1">;wait for safe to write to 8042</span>
    <span class="nf">xor</span> <span class="nb">cx</span><span class="p">,</span><span class="nb">cx</span>                          <span class="c1">;loop a maximum of FFFFh times</span>
 <span class="nl">enablea20kbwaitl0:</span>
    <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>                      <span class="c1">;these three jumps are inserted to</span>
 <span class="nf">wait</span> <span class="nv">some</span> <span class="nb">cl</span><span class="nv">ockcycles</span>
    <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>                      <span class="c1">;for the port to settle down</span>
    <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
    <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">64h</span>                          <span class="c1">;read 8042 status</span>
    <span class="nf">test</span> <span class="nb">al</span><span class="p">,</span><span class="mi">2</span>                          <span class="c1">;buffer full? zero-flag is set if</span>
 <span class="nf">bit</span> <span class="mi">2</span> <span class="nv">of</span> <span class="mh">64h</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">set</span>
    <span class="nf">loopnz</span> <span class="nv">enablea20kbwaitl0</span>           <span class="c1">;if yes (bit 2 of 64h is set), loop</span>
 <span class="nf">until</span> <span class="nb">cx</span><span class="err">=</span><span class="mi">0</span>
   <span class="nf">ret</span>

<span class="c1">;while the above loop is executing keyboard interrupts will occur which</span>
<span class="nf">will</span> <span class="nv">empty</span> <span class="nv">the</span> <span class="nv">buffer</span>
<span class="c1">;so be sure to have interrupts still enabled when you execute this code</span>

<span class="nl">enablea20test:</span>                        <span class="c1">;test for enabled A20</span>
   <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="kt">byte</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>                 <span class="c1">;get byte from 0:0</span>
   <span class="nf">mov</span> <span class="nb">ah</span><span class="p">,</span><span class="nb">al</span>                          <span class="c1">;preserve old byte</span>
   <span class="nf">not</span> <span class="nb">al</span>                             <span class="c1">;modify byte</span>
   <span class="nf">xchg</span> <span class="nb">al</span><span class="p">,</span><span class="kt">byte</span> <span class="p">[</span><span class="nb">gs</span><span class="p">:</span><span class="mh">10h</span><span class="p">]</span>              <span class="c1">;put modified byte to 0ffffh:10h</span>
                                      <span class="c1">;which is either 0h or 100000h</span>
<span class="nf">depending</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">a20</span> <span class="nv">state</span>
   <span class="nf">cmp</span> <span class="nb">ah</span><span class="p">,</span><span class="kt">byte</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>                 <span class="c1">;set zero if byte at 0:0 equals</span>
<span class="nf">preserved</span> <span class="nv">value</span>
                                      <span class="c1">;which means a20 is enabled</span>
   <span class="nf">mov</span> <span class="p">[</span><span class="nb">gs</span><span class="p">:</span><span class="mh">10h</span><span class="p">],</span><span class="nb">al</span>                    <span class="c1">;put back old byte at 0ffffh:10h</span>
  <span class="nf">ret</span>                                 <span class="c1">;return, zeroflag is set if A20</span>
<span class="nf">enabled</span>

<span class="nl">EnableA20:</span>                            <span class="c1">;hardware enable gate A20 (entry</span>
<span class="nf">point</span> <span class="nv">of</span> <span class="nv">routine</span>

   <span class="nf">xor</span> <span class="nb">ax</span><span class="p">,</span><span class="nb">ax</span>                          <span class="c1">;set A20 test segments 0 and 0ffffh</span>
   <span class="nf">mov</span> <span class="nb">fs</span><span class="p">,</span><span class="nb">ax</span>                          <span class="c1">;fs=0000h</span>
   <span class="nf">dec</span> <span class="nb">ax</span>
   <span class="nf">mov</span> <span class="nb">gs</span><span class="p">,</span><span class="nb">ax</span>                          <span class="c1">;gs=0ffffh</span>

   <span class="nf">call</span> <span class="nv">enablea20test</span>                 <span class="c1">;is A20 already enabled?</span>
   <span class="nf">jz</span> <span class="nv">short</span> <span class="nv">enablea20done</span>             <span class="c1">;if yes (zf is set), done</span>

<span class="c1">;if the system is PS/2 then bit 2 of port 92h (Programmable Option Select)</span>
<span class="c1">;controls the state of the a20 gate</span>

   <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">92h</span>                          <span class="c1">;PS/2 A20 enable</span>
   <span class="nf">or</span> <span class="nb">al</span><span class="p">,</span><span class="mi">2</span>                            <span class="c1">;set bit 2 without changing the rest</span>
<span class="nf">of</span> <span class="nb">al</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>                      <span class="c1">;Allow port to settle down</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">out</span> <span class="mh">92h</span><span class="p">,</span><span class="nb">al</span>                         <span class="c1">;enable bit 2 of the POS</span>
   <span class="nf">call</span> <span class="nv">enablea20test</span>                 <span class="c1">;is A20 enabled?</span>
   <span class="nf">jz</span> <span class="nv">short</span> <span class="nv">enablea20done</span>             <span class="c1">;if yes, done</span>

   <span class="nf">call</span> <span class="nv">enablea20kbwait</span>               <span class="c1">;AT A20 enable using the 8042</span>
<span class="nf">keyboard</span> <span class="nv">controller</span>
                                      <span class="c1">;wait for buffer empty (giving zf</span>
<span class="nf">set</span><span class="p">)</span>
   <span class="nf">jnz</span> <span class="nv">short</span> <span class="nv">enablea20f0</span>              <span class="c1">;if failed to clear buffer jump</span>

   <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0d1h</span>                        <span class="c1">;keyboard controller command 01dh</span>
<span class="err">(</span><span class="nf">next</span> <span class="kt">byte</span> <span class="nv">written</span> <span class="nv">to</span>
   <span class="nf">out</span> <span class="mh">64h</span><span class="p">,</span><span class="nb">al</span>                         <span class="c1">;60h will go to the 8042 output port</span>

   <span class="nf">call</span> <span class="nv">enablea20kbwait</span>               <span class="c1">;clear buffer and let line settle</span>
<span class="nf">down</span>
   <span class="nf">jnz</span> <span class="nv">short</span> <span class="nv">enablea20f0</span>              <span class="c1">;if failed to clear buffer jump</span>

   <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0dfh</span>                        <span class="c1">;write 11011111b to the 8042 output</span>
<span class="nf">port</span>
                                      <span class="c1">;(bit 2 is anded with A20 so we</span>
<span class="nf">should</span> <span class="nv">set</span> <span class="nv">that</span> <span class="nv">one</span><span class="p">)</span>
   <span class="nf">out</span> <span class="mh">60h</span><span class="p">,</span><span class="nb">al</span>

   <span class="nf">call</span> <span class="nv">enablea20kbwait</span>               <span class="c1">;clear buffer and let line settle</span>
<span class="nf">down</span>

<span class="nl">enablea20f0:</span>                          <span class="c1">;wait for A20 to enable</span>
   <span class="nf">mov</span> <span class="nb">cx</span><span class="p">,</span><span class="mh">800h</span>                        <span class="c1">;do 800h tries</span>

<span class="nl">enablea20l0:</span>
   <span class="nf">call</span> <span class="nv">enablea20test</span>                 <span class="c1">;is A20 enabled?</span>
   <span class="nf">jz</span> <span class="nv">enablea20done</span>                   <span class="c1">;if yes, done</span>

   <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">40h</span>                          <span class="c1">;get current tick counter (high</span>
<span class="nf">byte</span><span class="p">)</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">40h</span>                          <span class="c1">;get current tick counter (low byte)</span>
   <span class="nf">mov</span> <span class="nb">ah</span><span class="p">,</span><span class="nb">al</span>                          <span class="c1">;save low byte of clock in ah</span>

<span class="nl">enablea20l1:</span>                          <span class="c1">;wait a single tick</span>
   <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">40h</span>                          <span class="c1">;get current tick counter (high</span>
<span class="nf">byte</span><span class="p">)</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">jmp</span> <span class="nv">short</span> <span class="kc">$</span><span class="o">+</span><span class="mi">2</span>
   <span class="nf">in</span> <span class="nb">al</span><span class="p">,</span><span class="mh">40h</span>                          <span class="c1">;get current tick counter (low byte)</span>
   <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span><span class="nb">ah</span>                          <span class="c1">;compare clocktick to one saved in</span>
<span class="nf">ah</span>
   <span class="nf">je</span> <span class="nv">enablea20l1</span>                     <span class="c1">;if equal wait a bit longer</span>

   <span class="nf">loop</span> <span class="nv">enablea20l0</span>                   <span class="c1">;wait a bit longer to give a20 a</span>
<span class="nf">chance</span> <span class="nv">to</span> <span class="nv">get</span> <span class="nv">enabled</span>
   <span class="nf">stc</span>                                <span class="c1">;a20 hasn&#39;t been enabled so set</span>
<span class="nf">carry</span> <span class="nv">to</span> <span class="nv">indicate</span> <span class="nv">failure</span>
  <span class="nf">ret</span>                                 <span class="c1">;return to caller</span>
<span class="nl">enablea20done:</span>
   <span class="nf">clc</span>                                <span class="c1">;a20 has been enabled succesfully so</span>
<span class="nf">clear</span> <span class="nv">carry</span>
  <span class="nf">ret</span>                                 <span class="c1">;return to caller</span>
</pre></div>
<p>As you can see it requires quite a few lines of assembly to enable the a20
gate. This can pose a problem because a bootsector can only be a maximum
512 bytes. (And we still have to add code to load our kernel en place it
in memory) &lt;/p&gt;
In order to make some room we will remove the layout area
DOS uses to identify the disk. This forces us to write a program by which
we can write a file to the bootsector of our bootdisk.</p>
<p>&lt;/p&gt;&lt;center&gt;&lt;h2&gt;10. Writing a bootsector to a non-DOS disk&lt;/h2&gt;&lt;/center&gt;In contrast to all those lucky linux-users who have dd at their disposal,
a DOS or Windows user doesn't have an easy way of writing a binary image
to a floppy if it is not recognizable by DOS. Because our bootsector is
getting a bit full I really wanted to remove the block with diskinfo DOS
uses to recognize the disk. The problem is that it's then impossible to
use debug to write the bootsector to the floppy. So I decided to write my
very own WBS (Write BootSector).</p>
<p>So what has to be done to write an arbitrary file to the bootsector of a
floppy disk?  First of all the bootimage has to be read from the hard disk
and stored in memory. Then the buffer containing the bootsector has to be
written to the floppy disk.&lt;/p&gt;</p>
<p>&lt;/p&gt;&lt;pre&gt;;------------------------------------------------------------------------------------------
; wbs.asm  Write Boot Sector
;
; writes a binary file from harddisk to the bootsector of floppy 0 (a:)
;
; compile with NASM to binary file (nasm is assumed to be in your path)
;  nasm wbs.asm -o wbs.com
;
; written by emJay (c) 1999 last updated 18-06-99
;
;------------------------------------------------------------------------------------------</p>
<blockquote>
org 0x100</blockquote>
<dl class="docutils">
<dt>section .text</dt>
<dd>jmp Main</dd>
</dl>
<p>Welcome:        db      &quot;WBS Write Boot Sector v1.0 (c)1999
emJay.&quot;,10,13,'$'
AskInfile:      db      &quot;What is the location of the bootsector on your
hardisk?&quot;,10,13,&quot;:$&quot;
ErrorOpen:      db      &quot;An error has occurred.....quiting.&quot;,10,13,'$'
OpenSuccess:    db      &quot;File opened successfully.&quot;,10,13,'$'
InitSuccess:    db      &quot;Floppy initialised successfully.&quot;,10,13,'$'
WriteSuccess:   db      &quot;Bootsector written successfully.&quot;,10,13,'$'
Counter:                db      3</p>
<dl class="docutils">
<dt>Main:</dt>
<dd>mov ah,0x09
mov dx,Welcome
int 0x21
mov dx,AskInfile
int 0x21
xor si,si</dd>
<dt>InputLoop:</dt>
<dd>mov ah,0x01
int 0x21
cmp al,13
je InputDone
mov byte [Infile+si],al
inc si
jmp InputLoop</dd>
<dt>InputDone:</dt>
<dd><p class="first">mov byte [Infile+si],0
mov ax,0x3d00
mov dx,Infile
int 21h
jc  Error</p>
<p>mov [Handle],ax</p>
<p>mov ah,0x09
mov dx,OpenSuccess
int 0x21</p>
<p>mov ah,0x3f
mov bx,[Handle]
mov cx,0x200
mov dx,FileBuffer
int 0x21
mov bx,[Handle]
mov ah,0x3e
int 0x21</p>
<p class="last">xor ax,ax
mov dl,0
int 0x13
jc Error
mov ah,0x09
mov dx,InitSuccess
int 0x21</p>
</dd>
<dt>loop1:</dt>
<dd>mov ah,0
mov dl,0
int 0x13
mov al,1
mov ah,3
mov cx,1
mov dx,0
mov bx,FileBuffer
int 0x13
jnc WriteOK
dec byte [Counter]
jz  Error
jmp loop1</dd>
<dt>WriteOK:</dt>
<dd>mov ah,0x09
mov dx,WriteSuccess
int 0x21</dd>
<dt>Exit:</dt>
<dd>mov ah,1
mov dl,0
int 0x13
mov al,ah
mov ah,0x4c
int 0x21</dd>
<dt>Error:</dt>
<dd>mov ah,0x09
mov dx,ErrorOpen
int 0x21
jmp Exit</dd>
</dl>
<p>section .bss
Infile:         resb 80
Handle:         resb 1
FileBuffer:     resb 0x200
&lt;/pre&gt;</p>
<p>&lt;/p&gt;&lt;center&gt;&lt;h2&gt;11. All sources&lt;/h2&gt;&lt;/center&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/dumbboot.asm">http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/dumbboot.asm</a>&quot;&gt;dumbboot.asm&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/dosboot.asm">http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/dosboot.asm</a>&quot;&gt;dosboot.asm&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/pmboot.asm">http://web.archive.org/web/20010424064833/http://www.phys.uu.nl/~mjanssen/osdev/pmboot.asm</a>&quot;&gt;pmboot.asm&lt;/a&gt;
&lt;/li&gt;&lt;/ul&gt;
&lt;center&gt;&lt;h2&gt;12. Bibliography&lt;/h2&gt;&lt;/center&gt;&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Michael Tischer, PC Intern, ISBN 1-55755-145-6 &lt;br&gt;
A great book on all PC related stuff, it really takes you in depth on a
large number of subjects.
&lt;/li&gt;&lt;li&gt;Lance Leventhal, Lance Leventhal's 80386 programming guide, ISBN
90-6233-440-7 &lt;br&gt;
The most important parts of the intel 80386 manual, I don't know whether
the ISBN is for
the English book or the Dutch translation.
&lt;/li&gt;&lt;li&gt;Intel Architecture Software Developer's Manual, Volume 1: Basic
Architecture,
Volume 2: Instruction Set Reference, Volume 3: System Programming
Guide&lt;br&gt;
The manual for using Intel processors, it covers everything from registers
to instruction set and Protected Mode. These
manuals are downloadable from &lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.intel.com/">http://web.archive.org/web/20010424064833/http://www.intel.com/</a>&quot;&gt;Intel's web
site&lt;/a&gt; (approximatly 10 MB including
addenda).
&lt;/li&gt;&lt;li&gt;Ralph Brown's Interrupt List&lt;br&gt;A complete description of all the PC's
interrupts (including BIOS and DOS) and a description of all hardware
ports. A must have for every assembly programmer.
&lt;/li&gt;&lt;/ol&gt;
&lt;center&gt;&lt;h2&gt;13. Links&lt;/h2&gt;&lt;/center&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.webring.org/cgi-bin/webring?ring=os&amp;list">http://web.archive.org/web/20010424064833/http://www.webring.org/cgi-bin/webring?ring=os&amp;list</a>&quot; target=&quot;_top&quot;&gt;The
OS webring&lt;/a&gt;: Links to sites which are part of the Operating System
webring. It contains a lot of good links.
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.intel.com/">http://web.archive.org/web/20010424064833/http://www.intel.com/</a>&quot; target=&quot;_top&quot;&gt;Intel's web
site&lt;/a&gt;: for
all
information about Intel processors, chipsets
including datasheets and manuals. It is also possible to order a free
CD-ROM with the processor manuals and
a lot of other stuff.
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;<a class="reference external" href="http://web.archive.org/web/20010424064833/http://www.pobox.com/~ralf/files.html">http://web.archive.org/web/20010424064833/http://www.pobox.com/~ralf/files.html</a>&quot; target=&quot;_top&quot;&gt;Ralph
Brown's Home Page&lt;/a&gt;: here you can download the Ralph Brown Interrupt
list which contains all known and (unknown) interrupts and a description
of their usage.&lt;/li&gt;&lt;/ol&gt;
&lt;center&gt;&lt;h2&gt;14. Warranty&lt;/h2&gt;&lt;/center&gt;I exclude any and all implied warranties, including warranties of
merchantability and fitness for a particular purpose. I make no warranty
or
representation, either express or implied, with respect to this source
code,
its quality, performance, merchantability, or fitness for a particular
purpose. I shall have no liability for special, incidental, or
consequential
damages arising out of or resulting from the use or modification of this
source code.</p>
<p>Anyway I will by no means accept warranty for any damage caused by using
information and / or sources
found on this web page. So if you f**k up, kick yourself!!!
&lt;/p&gt;&lt;center&gt;&lt;h2&gt;15. Who am I&lt;/h2&gt;&lt;/center&gt;I am a twenty-four year old physics student from Utrecht in the
Netherlands. My name is emJay
(AKA Mark Janssen). Contact me at &lt;a href=&quot;<a class="reference external" href="mailto:mjanssen&#64;phys.uu.nl">mailto:mjanssen&#64;phys.uu.nl</a>&quot;&gt;mjanssen&#64;phys.uu.nl&lt;/a&gt;</p>
<p>&lt;center&gt;&lt;h2&gt;16. Update history&lt;/h2&gt;&lt;/center&gt;&lt;center&gt;
&lt;table width=&quot;90%&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;28 March 2000: &lt;/td&gt;&lt;td&gt;
Added link to OS webring in the links section.
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;14 March 2000: &lt;/td&gt;&lt;td&gt;
Used PHP3 to make navigation between pages possible and create the
contents (Yes, it is completly
automated).
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/center&gt;</p>
</div>
</div>

    
<div class=twitter>
<a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</div>
    <p class=tags>This entry was tagged as
      <a href="/tag/nasm.html">nasm</a>
    </p>
 
 
        </div>
        
<div class=footer>
  <p>&copy; Copyright <script language="JavaScript">var date = new Date(); document.write(date.getFullYear());</script> by Mark Janssen</p>
  <p> Powered by <a href="http://pypi.python.org/pypi/pelican/" target="_blank">Pelican</a>.  
    <a href="https://github.com/fjavieralba/flasky">Theme</a>  by <a href="http://fjavieralba.com">fjavieralba</a>
  </p> 
  <p>
    <div class=social style="font-size: 27px;">
      <ul>
        <script language="JavaScript">
          u = 'mpc.janssen';
          s = 'gmail.com';
          document.write('<a href=\"mailto:' + u + '@' + s + '\" target=\"_blank\">');
        </script>
            <li><i class="icon-envelope icon-large"></i> </li>
        </a>
        <a href="http://twitter.com/MPCtje" target="_blank"> <li> <i class="icon-twitter-sign icon-large"> </li></i> </a>
        <a href="https://www.linkedin.com/pub/mark-janssen/1/2a7/44"><li><i class="icon-linkedin-sign icon-large" ></i></li></a>
        <a href="http://github.com/mpcjanssen" target="_blank"> <li> <i class="icon-github-sign icon-large"></i> </li> </a>
        <a href="/feeds/all.atom.xml" rel="alternate" title="Recent Blog Posts"><li> <i class="icon-rss icon-large"></i> </li></a>
      </ul>
    </div>
  </p>
</div>    </div>
  </body>
</html>
